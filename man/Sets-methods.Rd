% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/AllMethods.R,
%   R/BaseSets-class.R
\docType{methods}
\name{Sets-methods}
\alias{Sets-methods}
\alias{relations}
\alias{relations<-}
\alias{elements}
\alias{elementData}
\alias{elementData<-}
\alias{sets}
\alias{setData}
\alias{setData<-}
\alias{nElements}
\alias{nSets}
\alias{setLengths}
\alias{elementLengths}
\alias{relations,Sets-method}
\alias{relations<-,Sets-method}
\alias{elementData,Sets-method}
\alias{elementData<-,Sets-method}
\alias{setData,Sets-method}
\alias{setData<-,Sets-method}
\alias{elements,Sets-method}
\alias{sets,Sets-method}
\alias{length,Sets-method}
\alias{nElements,Sets-method}
\alias{nSets,Sets-method}
\alias{setLengths,Sets-method}
\alias{elementLengths,Sets-method}
\alias{c.Sets}
\alias{c,Sets-method}
\alias{[,Sets,ANY,ANY,ANY-method}
\alias{[,Sets-method}
\alias{subset.Sets}
\alias{subset,Sets-method}
\alias{duplicated,Sets-method}
\alias{unique,Sets-method}
\alias{union.Sets}
\alias{union,Sets-method}
\alias{as.DataFrame.Sets}
\alias{as.DataFrame}
\alias{as.data.frame.Sets}
\alias{as.data.frame}
\alias{as.list.Sets}
\alias{as.list}
\alias{as.matrix.Sets}
\alias{as.matrix}
\alias{as.FuzzySets.Sets}
\alias{as.GOSets.Sets}
\alias{as.Sets.list}
\alias{as.Sets}
\alias{as.Sets.matrix}
\title{Methods for \code{Sets} Objects}
\usage{
relations(object)

relations(object) <- value

elements(object)

elementData(object)

elementData(object) <- value

sets(object)

setData(object)

setData(object) <- value

nElements(object)

nSets(object)

setLengths(object)

elementLengths(object)

\S4method{relations}{Sets}(object)

\S4method{relations}{Sets}(object) <- value

\S4method{elementData}{Sets}(object)

\S4method{elementData}{Sets}(object) <- value

\S4method{setData}{Sets}(object)

\S4method{setData}{Sets}(object) <- value

\S4method{elements}{Sets}(object)

\S4method{sets}{Sets}(object)

\S4method{length}{Sets}(x)

\S4method{nElements}{Sets}(object)

\S4method{nSets}{Sets}(object)

\S4method{setLengths}{Sets}(object)

\S4method{elementLengths}{Sets}(object)

\method{c}{Sets}(x, ...)

\S4method{[}{Sets,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\method{subset}{Sets}(x, ...)

\S4method{duplicated}{Sets}(x, incomparables = FALSE, ...)

\S4method{unique}{Sets}(x, incomparables = FALSE, ...)

union.Sets(x, y, ...)

as.DataFrame.Sets(object, ...)

\method{as.data.frame}{Sets}(x, ...)

\method{as.list}{Sets}(x, ...)

\method{as.matrix}{Sets}(x, ...)

as.Sets.list(list, ...)

as.Sets.matrix(matrix, ...)
}
\arguments{
\item{object, x}{An object of class inheriting from \code{\linkS4class{Sets}}.}

\item{value}{An object of a class specified in the S4 method signature or as outlined in 'Accessors'.}

\item{...}{Additional arguments passed to and from other methods.}

\item{i}{index specifying elements to extract or replace.}

\item{j}{Ignored.}

\item{drop}{A logical scalar indicating whether to remove orphan elements and sets from the \code{elementData} and \code{setData} slots, respectively.}

\item{incomparables}{Ignored.}

\item{y}{An object of class inheriting from \code{\link{Sets}}.}

\item{list}{A \code{list} of named character vectors.
The names are taken as the set identifiers.
The character vectors are taken as identifiers of elements that are member of each set.}

\item{matrix}{A \code{matrix}.
The matrix will be coerced to \code{logical} type and relations indicating \code{TRUE} will be stored in the \code{Sets}.}
}
\description{
This page documents the S4 generics and methods defined for objects inheriting of the \code{\linkS4class{Sets}} class.
In the usage below, \code{object} and \code{x} represent an object of class inheriting from \code{\linkS4class{Sets}},
and \code{value} is an object of a class specified in the S4 method signature or as outlined in 'Accessors'.
}
\section{Accessors}{

\code{relations(object)} returns the \code{relations} slot.
A \code{Hits} objets storing the integer index of elements (\code{from}) and sets (\code{to}) in the \code{elementData} and \code{setData} slots, respectively, and associated relation metadata (\code{mcols}).


\code{elementData(object)} returns the \code{elementData} slot.
An \code{\linkS4class{IdVector}} objets storing the unique element identifiers (\code{ids}) and associated element metadata (\code{mcols}).


\code{setData(object)} returns the \code{setData} slot.
An \code{\linkS4class{IdVector}} objets storing the unique set identifiers (\code{ids}) and associated set metadata (\code{mcols}).


\code{elements(object)} returns an \code{\linkS4class{IdVector}} element identifiers and associated metadata as ordered in \code{relations(object)$element}
(i.e., of length equal to \code{length(object)}).


\code{sets(object)} returns an \code{\linkS4class{IdVector}} of set identifiers and associated metadata as ordered in \code{relations(object)$set}.
(i.e., of length equal to \code{length(object)}).
}

\section{Dimensions}{

\code{length(x)} returns the total count of relations.


\code{nElements(object)} returns the count of unique elements.


\code{nSets(object)} returns the count of unique sets.


\code{setLengths(object)} returns the count of relations per set.


\code{elementLengths(object)} returns the count of relations per element.
}

\section{Combining}{

\code{c(x, ...)} combines its arguments
}

\section{Subsetting}{

\code{x[i, drop=TRUE]} returns new \code{\linkS4class{Sets}} object of the same class as \code{x} made of the elements selected by \code{i}. \code{i} can be missing; an \code{NA}-free logical, numeric, or character vector or factor (as ordinary vector or \code{\link{Rle}} object); or an \code{\link[=IntegerRanges-class]{IntegerRanges}} object.
The \code{drop} logical value controls whether the metadata of elements and sets orphaned during the subsetting should be removed from the \code{elementData} and \code{setData} slots, respectively.



\code{subset(object, subset, ..., drop=TRUE)} returns subsets of relations which meet conditions.
The \code{subset} argument should be a logical expression referring to any of \code{"element"}, \code{"set"}, and any available relation metadata indicating elements or rows to keep: missing values are taken as false.
The \code{drop} logical scalar controls whether elements and sets orphaned during the subsetting should be removed from the \code{elementData} and \code{setData} slots, respectively.
}

\section{Duplication and uniqueness}{

\code{duplicated(x)} determines which relations of a \code{Sets} are duplicates of relations with smaller subscripts, and returns a logical vector indicating which relations are duplicates.



\code{unique(x)} returns a \code{Sets} like \code{x} but with duplicate relations removed.



\code{union(x)} returns a \code{Sets} composed of the union of relations in \code{x} and \code{y}.
}

\section{Coercion from Sets}{

\code{as(object, "DataFrame")} and \code{as.DataFrame(object)} return a nested \code{DataFrame} including columns \code{"element"}, \code{"set"}, \code{"relationData"}, \code{"elementData"}, and \code{"setData"}.


\code{as(x, "data.frame")} and \code{as.data.frame(x)}  return a flattened \code{data.frame} including \code{"element"}, \code{"set"}, and columns in \code{mcols(relations(x))} if any.


\code{as(x, "list")} and \code{as.list(x)} return a named \code{list}.
Names are set identifiers, and values are character vectors of element identifiers.


\code{as(x, "matrix")} and \code{as.matrix(x)} return a \code{matrix} with elements as rows, sets as columns, and a \code{logical} value to indicate membership.
}

\section{Coercion to Sets}{

\code{as(list, "Sets")} and \code{as.Sets(object)} return a \code{Sets} from a list of character vectors.


\code{as(matrix, "Sets")} and \code{as.Sets(object)} return a \code{Sets} from an incidence matrix.
}

\examples{
# Constructor ----

# Visually intuitive definition of sets
sets <- list(
  set1=c("A", "B"),
  set2=c("B", "C", "D"),
  set3=c("E"))

bs <- as(sets, "Sets")
bs

# Accessors ----

relations(bs)

bs1 <- bs
mcols(relations(bs1))[["NEW"]] <- paste0("value", seq_len(length(bs1)))

elementData(bs)

bs1 <- bs
mcols(elementData(bs1))[["NEW"]] <- paste0("value", seq_len(nElements(bs1)))

setData(bs)

bs1 <- bs
mcols(setData(bs1))[["NEW"]] <- paste0("value", seq_len(nSets(bs1)))

elements(bs)
ids(elements(bs))
mcols(elements(bs))

sets(bs)
ids(sets(bs))
mcols(sets(bs))

# Dimensions ----

length(bs)
nElements(bs)
nSets(bs)
setLengths(bs)
elementLengths(bs)

# Combining ----

bs1 <- c(bs, bs)

# Subsetting ----

bs1 <- bs[1:5]
bs1 <- bs[1:5, , drop=FALSE] # keep metadata of orphan elements and sets

bs1 <- subset(bs, set == "set1" | element == "E")
bs1

# Duplication and uniqueness ----

bs1 <- bs
relations(bs1) <- rep(relations(bs1), each=2)
table(duplicated(bs1))
unique(bs1)
bs1 <- union(bs, bs)

# Coercion from Sets ----

DF1 <- as(bs, "DataFrame")

df1 <- as.data.frame(bs)

l1 <- as(bs, "list")

m1 <- as(bs, "matrix")

bs1 <- bs
mcols(relations(bs1))[["membership"]] <- runif(length(bs1))
fs <- as(bs1, "FuzzySets")

# Fetch a sample of GO annotations
library(org.Hs.eg.db)
gs <- import(org.Hs.egGO)
bs1 <- as(gs, "Sets")
gs1 <- as(bs1, "GOSets")

# Coercion to Sets ----

# list
bs1 <- as(list(set1=c("A", "B"), set2=c("B", "C")), "Sets")
# matrix
bs1 <- as(m1, "Sets")
}
\seealso{
\code{\linkS4class{Sets}}.
}
\author{
Kevin Rue-Albrecht
}
